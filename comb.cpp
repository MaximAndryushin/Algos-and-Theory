#include<bits/stdc++.h>

#define endl "\n"
using namespace std;
using ll = long long;
using ld = long double;
using pii = pair<int, int>;

constexpr int N = 1e9 + 7;

/* Задача восстановления объекта по номеру и номера по объекту 
перебираем возможные варианты эл - ов и ставим если к - ый попал в кол-во Элементов, имеющий такой префикс
*/

//комбинаторная строка из 0 и 1 (не могут быть две 1 подряд)
/*
1) 00000
2) 00001
3) 00010
4) 00100
5) 00101
6) 01000
7) 01001
8) 01010
9) 10000
10) 10001
11) 10010
12) 10100
13) 10101

F(n) = F(n - 1) + F(n - 2) - кол-во строк
*/

//Перестановки
// та же техника
// только на каждой итерации можно находить нужный номер элемент за константу и потом по номеру в декартовом или в до находить


//Правильная скобочная последовательность
//dp[i][bal] - кол-во "правильных" скобочных последовательностей длины i и баланс bal
//dp[i][bal] = dp[i - 1][bal - 1] + dp[i - 1][bal + 1]
//find kth sequence
//тот же подход
//1) знаем длинв префикса - баланс
//2) переворачиваем суффикс и получаем ответ
//на графике легко доказать, вверх, вниз переходы


void Solve(){

}

int main(){
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);
  Solve();
  return 0;
}